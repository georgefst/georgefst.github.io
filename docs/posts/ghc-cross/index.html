<!DOCTYPE HTML>
<html><head><meta charset="UTF-8"><title>Cross compiling Haskell (without Nix) | George Thomas</title><link rel="stylesheet" href="/style.css"><link rel="stylesheet" href="/generated.css"></head><body><div id="sidebar"><a href="/" id="home-image"><img src="/me.avif"></a><a href="/posts" class="button-link">Blog</a><a href="/portfolio" class="button-link">Portfolio</a><a href="/work" class="button-link">Hire me!</a></div><div id="content" class="posts/ghc-cross"><div><h1>Cross compiling Haskell (without Nix)</h1>
<p>This is a guide to building GHC as a <a href="https://en.wikipedia.org/wiki/Cross_compiler">cross compiler</a>, i.e. creating a <code>ghc</code> executable which runs in one environment and outputs code for another. The most common motivation for this is a desire to run Haskell code on a machine which is not itself powerful enough to run GHC effectively.</p>
<p>We'll be using the following configuration:</p>
<ul>
<li>An Intel-powered Arch Linux system is used both as the <em>build</em> environment (where the compiler is built) and the <em>host</em> environment (where the compiler runs).</li>
<li>The <em>target</em> environment (where the code produced by the compiler will run) is a fourth-generation Raspberry Pi running Raspberry Pi OS.</li>
</ul>
<p>Much of this guide will generalise to other setups, at least for GNU/Linux. it's likely that the only differences will be in how you get hold of an appropriate GCC toolchain [link to below]. and what prefix you pass in place of <code>aarch64-none-linux-gnu</code> and so long as running <code>uname -m</code> outputs <code>x86_64</code> on the build/host system (which will be the case for the vast majority of non-Mac laptops and desktops <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>) and <code>aarch64</code> for the target (most Pi-esque cheap computers), you can probably use the same ARM toolchain used here, you'll just have to find some way to unpack it manually if you're not on Arch</p>
<p>We'll be using GHC 9.10.1, though there haven't been <em>major</em> changes to any of this since 9.2, which introduced the aarch64 backend [what about Hadrian?] [see Historical Notes section] and GCC _</p>
<h2>Why not just use Nix?</h2>
<p>I love the <em>idea</em> of Nix, and have used it extensively on some large projects, but it often makes for a frustrating experience. The major pain points being awful documentation and error messages. I won't go in to more detail here because it's <a href="https://blog.wesleyac.com/posts/the-curse-of-nixos">all</a> <a href="https://remy.grunblatt.org/nix-and-nixos-my-pain-points.html">been</a> <a href="https://ianthehenry.com/posts/how-to-learn-nix/introduction">said</a> <a href="https://serokell.io/blog/haskell-in-production-mercury">before</a>.</p>
<p>we really need proper hyperlink highlighting here</p>
<p>I'm also wary of the "just use Nix" answer that's often given to all sorts of questions on Haskell forums. It can send new users down a major rabbit hole, and even give a false impression that mastering Nix is <em>necessary</em> in order to work effectively with Haskell. We often don't seem to realise how simple the non-Nix approach can be, particularly for problems which have become simpler over time due to upstream tooling improvements. In that vein, I'm somewhat inspired by <a href="https://hasufell.github.io/posts/2024-04-21-static-linking.html">this post on static linking</a>.</p>
<p>One place where Nix is currently the only serious option (?) is TemplateHaskell I don't know if anyone using ghc iserv without Nix https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/compiler/external-interpreter haskell.nix sets it up for you with qemu Do both haskell Nix solutions solve this equally? aha, cross compilation was haskell.nix's original raison detre https://www.reddit.com/r/haskell/comments/h0e5ui/comment/ftnn2de/?utm<em>source=share&amp;utm</em>medium=web3x&amp;utm<em>name=web3xcss&amp;utm</em>term=1&amp;utm<em>content=share</em>button</p>
<p>well, actually, I guess using qemu for the whole thing is also an option but much slower https://www.reddit.com/r/haskell/comments/h0e5ui/comment/fto9eq9/?utm<em>source=share&amp;utm</em>medium=web3x&amp;utm<em>name=web3xcss&amp;utm</em>term=1&amp;utm<em>content=share</em>button</p>
<p>and of course I use qemu rather than Haskell.nix's own cross-compilation for my nixos-config repo</p>
<p>although things should in principle be much simpler as we often just want stuff like <code>makeLenses</code> which is platform-independent and should be able to run on host there's some serious work slowly happening to untangle the relevant parts of the compiler https://github.com/ghc-proposals/ghc-proposals/pull/682 on the other hand, it's surprising how few common libraries rely on TH these days I've build some projects with pretty huge dependency graphs where it hasn't been a problem</p>
<h2>Steps</h2>
<p>This is a CPU-intensive process, so you may wish to close down most windows in order to speed it up<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<p>took 17m on Billy with quick a mid-range 2021 laptop with an i7 and 16GB of RAM what about Crow?</p>
<h2>Install an appropriate cross-compiling GCC</h2>
<p>this is, as mentioned, the part that you'll have to do quite differently if you're not on Arch</p>
<p>The easiest way to do this on Arch is to use your favourite AUR helper e.g. run <code>yay aarch64-none-linux-gnu-gcc</code> and select an appropriate package we'll use <a href="https://aur.archlinux.org/packages/aarch64-none-linux-gnu-gcc-12.3-bin"><code>gcc-12.3</code></a> for <code>glibc</code> reasons how do we know how to match?</p>
<p>Note that you should always be careful when it comes to trusting AUR packages basically unmoderated (?) source is fortunately small and clearly basically just downloads a tarball from a reputable website and unpacks stuff yes you should read the source in principle, but all the Hackage packages you're depending on are a similar threat (?) <a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<p>There is an official package at <code>extra/aarch64-linux-gnu-gcc</code> but I've never used it since, Arch being what it is, it's always too up-to-date to be useful unless targeting a system which also uses the very latest <code>glibc</code>. If, for example, you're running Arch on your target device, then this <em>should</em> work.</p>
<h2>GHCup cross-compilation</h2>
<p>link back to https://discourse.haskell.org/t/wasm-and-singletons-base/10972/4?u=george.fst (not sure why I said that?)</p>
<p>tools: https://gitlab.haskell.org/ghc/ghc/-/wikis/building/preparation/linux#arch since we're using a source distribution, won't need alex or happy well, that was a lie... this would appear to be a lie: https://gitlab.haskell.org/ghc/ghc/-/wikis/building/getting-the-sources#via-source-distributions unless they're just needed for cross for some reason can't build native to test because I hit latex errors - work out how to disable doc build? punt this as GHC issue it's likely everything else needed is already installed maybe <code>sudo pacman -S autoconf automake</code> just make sure you have a normal recent GHC and Cabal installed via GHCup</p>
<p>grab your preferred source distribution, as described <a href="https://gitlab.haskell.org/ghc/ghc/-/wikis/building/getting-the-sources">here</a> e.g. we're using GHC 9.10.1 as it's the latest reasonably stable version I should try 9.6 and/or 9.8 on Crow to see whether they hit separate errors I think they did and it would be a good excuse to ignore them and stay cutting edge maybe even 9.4 (GHCup recommended) and 9.2 (first with native aarch64 backend (and Hadrian? or was that 9.4?))</p>
<p><code>sh curl https://downloads.haskell.org/~ghc/9.10.1/ghc-9.10.1-src.tar.xz -o ghc-9.10.1-src.tar.xz tar xf ghc-9.10.1-src.tar.xz cd ghc-9.10.1 ./configure --target=aarch64-none-linux-gnu GHC=ghc-9.6 ./hadrian/build -j$(nproc) --flavour=quick+native_bignum binary-dist</code></p>
<p>the configure step shouldn't take more than a minute / a few seconds (13 on Crow) is this even worth saying?</p>
<p>actual build took 20m19s on Crow with nproc, although that was accidentally using 9.6 to build pretty sure Billy took 17 something</p>
<p>is <code>-j4</code> faster than nproc on Crow with all its cores? should try it</p>
<p>(specifying <code>GHC=9.6.5</code> is necessary in order to avoid errors very similar to https://gitlab.haskell.org/ghc/ghc/-/issues/24364 but only when building 9.10.1 release, not HEAD not sure why... )</p>
<p>It <em>should</em> be possible to just run the following: <code>ghcup compile ghc --hadrian -v 9.10.1 -b 9.10.1 -x aarch64-none-linux-gnu -j $(nproc) --flavour=quick+native_bignum --hadrian-ghc=9.6</code> But GHCup's support for (cross compilation with?) Hadrian is currently broken https://gitlab.haskell.org/ghc/ghc/-/issues/23983</p>
<p>NB I have the bindist on Crow's Desktop for now, with a hacky <code>PATH</code> modification in <code>aarch64-none-linux-gnu-cabal</code> undocumented! i.e. <code>cp -r _build/bindist/ghc-9.10.1-aarch64-none-linux-gnu ~/Desktop/aarch64-ghc-prefix/</code> should suggest putting somewhere on PATH I guess? and now Billy too, as of 2025/01/20!</p>
<h3>alternatively, if needing a particular commit</h3>
<p><code>sh git clone --recursive https://gitlab.haskell.org/ghc/ghc.git cd ghc git checkout ghc-9.10.1-release</code></p>
<p>various intermediate steps between clone and configure autoconf, init submodules... or is this just what boot script does? is this where we again hit issue where Arch Happy is too new for GHC 9.10 (<code>cabal install happy-1.20.1.1</code>)? didn't happen when building from source tarball</p>
<h2>cabal-install wrapper</h2>
<p>simple</p>
<p>inspired by moritz</p>
<p>...</p>
<h2>third-party libs - work through evdev/zlib example</h2>
<p>there's no particular reason that these steps couldn't also be turned in to AUR packages</p>
<ul>
<li>also publish AUR packages for cross-compiling libevdev, zlib etc. ?
<ul>
<li>is Debian a step above here? https://github.com/Spotifyd/spotifyd/pull/122/files
<ul>
<li>EDIT also https://gitlab.haskell.org/ghc/ghc/-/wikis/building/cross-compiling-on-debian</li>
</ul></li>
<li>depend on my <code>gcc</code> package?
<ul>
<li>or do we not need to be tied to a version
<ul>
<li>actually, I don't think that's an issue as these would be built from source
<ul>
<li>we would need to make sure they're rebuilt when compiler is upgraded
<ul>
<li>in the way that <code>ghcid</code> should be (but isn't) when libraries it depends on are upgraded</li>
</ul></li>
</ul></li>
</ul></li>
<li>it does seem a bit weird to have them all tied to my GCC instead of the package in <code>community</code>
<ul>
<li>but obviously <em>I</em> can't use that because glibc is too bleeding edge for RPi and sometimes even NixOS
<ul>
<li>unless there is some way to compile against an older glibc?</li>
</ul></li>
</ul></li>
</ul></li>
<li>alternatively, Haskell <code>zlib</code> package has a <code>bundled-c-zlib</code> flag
<ul>
<li>investigate
<ul>
<li>seems to have been designed for Windows but may well work with cross-compilation</li>
<li>maybe it isn't actually a great approach: https://github.com/haskell/zlib/issues/22</li>
<li>added in 2020 (and renamed): https://github.com/haskell/zlib/pull/31</li>
</ul></li>
<li>recommend that and provide similar in evdev?</li>
<li>actually, I've seen this in a few other places now, including Rust <code>openssl</code> lib</li>
</ul></li>
</ul></li>
</ul>
<p><code>sh cd ~/Desktop # LIBEVDEV_VERSION=1.13.1 LIBEVDEV_VERSION=1.13.3 curl -OL https://www.freedesktop.org/software/libevdev/libevdev-$LIBEVDEV_VERSION.tar.xz tar xf libevdev-$LIBEVDEV_VERSION.tar.xz cd libevdev-$LIBEVDEV_VERSION ./configure --host=aarch64-none-linux-gnu --prefix=/usr/aarch64-none-linux-gnu/ make sudo make install</code></p>
<p><code>sh cd ~/Desktop # ZLIB_VERSION=1.2.13 ZLIB_VERSION=1.3.1 curl -OL https://www.zlib.net/zlib-$ZLIB_VERSION.tar.gz tar xzf zlib-$ZLIB_VERSION.tar.gz cd zlib-$ZLIB_VERSION CHOST=aarch64-none-linux-gnu ./configure --prefix=/usr/aarch64-none-linux-gnu/ make sudo make install</code></p>
<p>what's this for? oh, stuff like Brick I guess</p>
<p><code>sh cd ~/Desktop CURSES_VERSION=6.4 curl -OL https://invisible-island.net/archives/ncurses/ncurses-$CURSES_VERSION.tar.gz tar xzf ncurses-$CURSES_VERSION.tar.gz cd ncurses-$CURSES_VERSION # without `--enable-overwrite`, headers end up in a prefixed directory where Haskell `terminfo` library can't find them # I'm not quite sure why `--disable-stripping` was needed (18/10/2023), and maybe we can set `STRIP` env var instead ./configure --host=aarch64-none-linux-gnu --prefix=/usr/aarch64-none-linux-gnu --enable-overwrite --disable-stripping make sudo make install</code></p>
<p>any other, e.g. openssl?</p>
<h2>test</h2>
<p><code>sh cd ~/code/hello-hs aarch64-none-linux-gnu-cabal build scp $(aarch64-none-linux-gnu-cabal list-bin .) pi:/tmp ssh pi /tmp/hello-hs</code></p>
<p>do a trivial non-cabal hello world then a cabal script utilising zlib and maybe one of evdev-examples</p>
<h2>historical notes</h2>
<p>I've been following these developments closely for 6 years have been posting bits of it for at least 3 years: https://www.reddit.com/r/haskell/comments/ryw1go/comment/hruafla publishing this before it hopefully becomes obsolete!</p>
<p>docker winter - Rust aarch64 GHC backend https://gitlab.haskell.org/ghc/ghc/-/issues/17973#note_378621 aarch64 for RPiOS this has all been getting easier angerman work RPi going 64-bit OS by default about two years ago? Hadrian over Make</p>
<p>this works so well that perhaps GHC should provide bindists?</p>
<p>future - runtime retargetability would make a lot of this obsolete explain exactly what? https://www.reddit.com/r/haskell/comments/zk1qs6/comment/j09kcjb/?utm<em>source=share&amp;utm</em>medium=web2x&amp;context=3 https://gitlab.haskell.org/ghc/ghc/-/issues/11470 https://gitlab.haskell.org/ghc/ghc/-/issues/23682</p>
<p>as for the need for this guide, there's some good stuff on the GHC wiki but it tends to be surrounded be a sea of obscure or outdated information in particular, the cross pages don't mention Hadrian, and vice versa besides, I think there's value in a guide focussed on a particular common scenarion and largely on the happy path footnote: and I don't personally feel qualified to fix that plus doing it in full generality is quite a task and probably best left to a GHC dev who actually works on this stuff https://gitlab.haskell.org/ghc/ghc/-/wikis/cross-compilation/ https://gitlab.haskell.org/ghc/ghc/-/wikis/building/cross-compiling</p>
<h2>misc</h2>
<p>go to Haskell Discourse to leave a comment</p>
<p>George Thomas 30/01/2025</p>
<p>1st February 2025</p>
<h1>footnotes</h1>
<p>proper highlighting why doesn't browser back button do what I'd hope for (can punt if I'm calling website WIP when launching this post)</p>
<p>one advantage of not using GHCup is that build products are cached such that if something trivial goes wrong then we don't start from scratch I suspect that it wouldn't be difficult to patch GHCup to improve this I suffered with this a lot a while ago, though it's maybe less relevant when following this guide anyway EDIT: actually would have hit it several times when trying minor variations of these commands</p>
<p>there's a common sentiment (misconception?) that Haskell on Arch is a disaster due to dynamic linking it's actually fine as long as you use GHCup for development, and make sure it's directory is first on <code>PATH</code> this is another thing that I've also posted in various places over the years it could form the basis of another blog post but honestly, there's not much more to say on the matter than that</p>
<ul>
<li>alternative - "sysroot" approach
<ul>
<li>there are plenty of guides online about this, but it's not the approach I've taken - essentially:
<ul>
<li>install any aarch64 libraries you need via the package manager on the Pi e.g. Apt</li>
<li>copy files from the Pi to create a "sysroot" folder</li>
</ul></li>
<li>https://downloads.raspberrypi.org/raspios<em>lite</em>arm64/root.tar.xz</li>
<li>I prefer just building myself</li>
</ul></li>
</ul>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>and if not, then you're host is probably also <code>aarch64</code> in which case you don't need this guide at all (well, actually, unless the target isn't)<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>compared to when I started doing this in 2021 on the same machine, OOMs seem to have stopped happening - not sure if that's down to Hadrian, GHC itself, OS improvements or anything else<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>in my case, at time of writing, the <code>PKGBUILD</code> file contains only trivial differences from <a href="https://aur.archlinux.org/packages/aarch64-none-linux-gnu-gcc-10.3-bin">a previous version which I maintained myself</a> so that's more than enough for me personally<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></div></body></html>